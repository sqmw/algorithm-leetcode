# LEETCODE

- 做题换算 难 = 2 * 中等 == 4 * 简单
    - 做到需要收费的时候每天 4 题及其以下
- 变量定义域的使用按照C语言使用(更加规范)
- 编写算法不仅需要保证性能，也需要保证代码的可读性
- 160题附近开始收费，此时已经做完所有的数据结构一遍了(似乎还差图，但是树也是特殊的图)
- 本人算法实现规则：
    - 时间复杂度需要达到最低
    - 空间复杂度不超过O(n)即可，对于空间复杂度的要求非必要不降低到O(1)

## 算法实现

1. 循环
2. 递归
3. 动态规划

### 递归 == 循环 + 栈

*`递归和循环的S、T各不相同`*

## 算法使用的数据结构

1. 线性表
2. 字符串
3. 树
4. 图

## 算法思想

1. 贪心算法
2. 动态规划

- 动态规划的本质：
    - 数学归纳法(递推公式)
    - f(x) = f(x - 1) + f(x - 2) + ...(第n项的结果由前面的某m项决定)

3. traceback(216)

```
if condition_if:
    des_arr.append(path[:])
else:
    for condition_for:
        path.append()
        traceback()
        path.pop()
```

### 贪心算法难题

- 未证明可行性: 162
- 看答案做出题:
    - 179(内置排序算法，想到但是不能排序出来)
      ```
        nums = [2, 1, 3, 4, 1, 2, 3, 4]
        def cmp(x, y):
            return x - y # -1 理解为 每次 x 取出最小的一个 x(java的比较函数就是这样)
        nums.sort(key=functools.cmp_to_key(cmp))
        print(nums)  # [1, 1, 2, 2, 3, 3, 4, 4]       
      ```

### 回溯思想难题

题目序号：39 78 90

### 动态规划难题

题目序号：73,139

### 时间上面需要提升的题目

| 题目序号 | 题目描述                   | 总结 |
|------|------------------------|----|
| 105  | 需要加深二叉树 先序\|中序 遍历特性的理解 | ?  |
| 106  | 需要加深二叉树 中序\|后序 遍历特性的理解 | ?  |
| 130  | 广度优先遍历/二维数组            | ?  |

### 未做出来题目

| 题目序号                         | 知识点       | 总数 |
|------------------------------|-----------|----|
| 95(3) 、 96(3)[需要做出98题再来做这两题] | 树的遍历      | 1  |
| 241                          | 和 95 一个类型 | 2  |
| 292                          | NIM游戏和博弈论 | 3  |

### bit manipulation(位运算)

| 201 | ... | ... | ... |
|-----|-----|-----|-----|
|     |     |     |     |

### 其他

#### 数学

| 题目序号 | 题目知识  |
|------|-------|
| 204  | prime |
|      |       |
|      |       |

#### 有趣的题目

| 题目序号 | 描述                  |
|------|---------------------|
| 205  | 同构字符串               |
| 207  | 图的遍历、环的判定           |
| 227  | 一般表达式求值             |
| 232  | 双栈实现队列&&T(n) = O(1) |
| 238  | productExceptSelf   |
| 241  | 表达式添加括号的不同方法        |
| 274  | 计数排序                |
| 287  | Floyd 数组重复数字判定/抽屉原理 |
| 292  | NIM游戏、博弈论           |
